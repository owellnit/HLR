{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf600
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red138\green243\blue244;\red189\green255\blue203;
\red219\green183\blue255;}
{\*\expandedcolortbl;\csgray\c100000;\cssrgb\c0\c0\c0;\cssrgb\c60000\c95686\c96471;\cssrgb\c78039\c100000\c83529;
\cssrgb\c89020\c78039\c100000;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid1\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid101\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid201\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid301\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid401\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid5}
{\list\listtemplateid6\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid501\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid6}
{\list\listtemplateid7\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid601\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid7}
{\list\listtemplateid8\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid701\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid8}
{\list\listtemplateid9\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid801\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid9}
{\list\listtemplateid10\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid901\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid10}
{\list\listtemplateid11\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid1001\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid11}
{\list\listtemplateid12\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid1101\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid12}
{\list\listtemplateid13\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid1201\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid13}
{\list\listtemplateid14\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid1301\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid14}
{\list\listtemplateid15\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid1401\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid15}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}{\listoverride\listid7\listoverridecount0\ls7}{\listoverride\listid8\listoverridecount0\ls8}{\listoverride\listid9\listoverridecount0\ls9}{\listoverride\listid10\listoverridecount0\ls10}{\listoverride\listid11\listoverridecount0\ls11}{\listoverride\listid12\listoverridecount0\ls12}{\listoverride\listid13\listoverridecount0\ls13}{\listoverride\listid14\listoverridecount0\ls14}{\listoverride\listid15\listoverridecount0\ls15}}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl280\partightenfactor0

\f0\fs24 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 *****Hochleistungsrechnen Blatt02 *****/\cb1 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf2 \cb4 Simple Code:\cb1 \
\cb4 /*\cb1 \
\cb4 \'a0** simple error demonstration to demonstrate power of valgrind\cb1 \
\cb4 \'a0** Julian M. Kunkel - 17.04.2008\cb1 \
\cb4 \'a0*/\cb1 \
\
\cb4 #include <stdio.h>\cb1 \
\cb4 #include <stdlib.h>\cb1 \
\
\cb4 int *\cb1 \
\cb4 mistake1 ()\cb1 \
\cb4 \{\cb1 \
\cb4 \'a0\'a0\'a0 int* buf = malloc (sizeof(int) * 2);\cb1 \
\cb4 \'a0\'a0\'a0 buf[1] = 1;\cb1 \
\cb4 \'a0\'a0\'a0 return buf;\cb1 \
\cb4 \}\cb1 \
\
\cb4 int *\cb1 \
\cb4 mistake2 ()\cb1 \
\cb4 \{\cb1 \
\cb4 \'a0\'a0\'a0 int *buf = malloc (sizeof (int) * 2);\cb1 \
\cb4 \'a0\'a0\'a0 buf[1] = 2;\cb1 \
\cb4 \'a0\'a0\'a0 return buf;\cb1 \
\cb4 \}\cb1 \
\
\cb4 int *\cb1 \
\cb4 mistake3 ()\cb1 \
\cb4 \{\cb1 \
\cb4 \'a0\'a0\'a0 int mistake2_ = 0;\cb1 \
\cb4 \'a0\'a0\'a0 int *buf = malloc (sizeof (mistake2_));\cb1 \
\cb4 \'a0\'a0\'a0 buf[0] = 3;\cb1 \
\cb4 \'a0\'a0\'a0 return buf;\cb1 \
\cb4 \}\cb1 \
\
\cb4 int *\cb1 \
\cb4 mistake4 ()\cb1 \
\cb4 \{\cb1 \
\cb4 \'a0\'a0\'a0 int *buf = malloc (sizeof (int) * 1);\cb1 \
\cb4 \'a0\'a0\'a0 buf[0] = 4;\cb1 \
\cb4 \'a0\'a0\'a0 // free (buf);\cb1 \
\cb4 \'a0\'a0\'a0 return buf;\cb1 \
\cb4 \}\cb1 \
\
\cb4 int\cb1 \
\cb4 main (void)\cb1 \
\cb4 \{\cb1 \
\cb4 \'a0\'a0\'a0 /* Modifizieren Sie die folgende Zeile nicht */\cb1 \
\cb4 \'a0\'a0\'a0 int *p[4] = \{ &mistake1 ()[1], &mistake2 ()[1], mistake3 (), mistake4 () \};\cb1 \
\cb4 \'a0\'a0\'a0\'a0\cb1 \
\cb4 \'a0\'a0\'a0 printf ("1 %d\\n", *p[0]);\cb1 \
\cb4 \'a0\'a0\'a0 printf ("2 %d\\n", *p[1]);\cb1 \
\cb4 \'a0\'a0\'a0 printf ("3 %d\\n", *p[2]);\cb1 \
\cb4 \'a0\'a0\'a0 printf ("4 %d\\n", *p[3]);\cb1 \
\cb4 \'a0\'a0\'a0\'a0\cb1 \
\cb4 \'a0\'a0\'a0 /* mhh muss hier noch etwas gefreed werden? */\cb1 \
\cb4 \'a0\'a0\'a0 /* F\'fcgen sie hier die korrekten aufrufe von free() ein */\cb1 \
\cb4 \'a0\'a0\'a0 free (p[0]- 1);\cb1 \
\cb4 \'a0\'a0\'a0 free (p[1]- 1);\cb1 \
\cb4 \'a0\'a0\'a0 free (p[2]);\cb1 \
\cb4 \'a0\'a0\'a0 free (p[3]);\cb1 \
\cb4 \'a0\'a0\'a0 /* welcher Pointer war das doch gleich?, TODO: Fixme... :-) */\cb1 \
\cb4 \'a0\'a0\'a0\'a0\cb1 \
\cb4 \'a0\'a0\'a0 return 0;\cb1 \
\cb4 \}\cb1 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf2 \cb3 GDB Ausgabe f\'fcr Simple\cb1 \
\
\cb3 mistake1:\'a0\cb1 \
\cb3 Line 12:\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 int buf[] = \{ 1, 1, 2, 3, 4, 5 \};\cb1 \
\cb3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 (gdb) info locals\cb1 \
\cb3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 buf = \{0, 0, 0, 0, 1, 0\}\cb1 \
\cb3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 (gdb) p buf[2]\cb1 \
\cb3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 $2 = 0\cb1 \
\cb3 Line 13:\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return buf;\cb1 \
\cb3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 (gdb) info locals\cb1 \
\cb3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 buf = \{1, 1, 2, 3, 4, 5\}\cb1 \
\cb3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 (gdb) p buf[2]\cb1 \
\cb3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 $3 = 2\cb1 \
\
\cb3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 (gdb) whatis buf\cb1 \
\cb3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 type = int [6]\cb1 \
\
\cb3 Line 15:\cb1 \
\cb3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 (gdb) whatis buf\cb1 \
\cb3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 type = int *\cb1 \
\
\cb3 mistake2:\cb1 \
\cb3 Line19:\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 int *buf = malloc (sizeof (char) * 4);\cb1 \
\cb3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 (gdb) whatis buf\cb1 \
\cb3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 type = int *\cb1 \
\
\cb3 mistake3:\cb1 \
\cb3 Program received signal SIGSEGV, Segmentation fault.\cb1 \
\cb3 0x00000000004006fc in mistake3 () at simple.c:29\cb1 \
\
\cb3 29\'a0\'a0\'a0\'a0\'a0\'a0\'a0 buf[0] = 3;\cb1 \
\cb3 (gdb) l\cb1 \
\cb3 24\'a0\'a0\'a0\'a0\'a0 int *\cb1 \
\cb3 25\'a0\'a0\'a0\'a0\'a0 mistake3 ()\cb1 \
\cb3 26\'a0\'a0\'a0\'a0\'a0 \{\cb1 \
\cb3 27\'a0\'a0\'a0\'a0\'a0\'a0\'a0 int mistake2_ = 0;\cb1 \
\cb3 28\'a0\'a0\'a0\'a0\'a0\'a0\'a0 int *buf = (int *) &mistake2;\cb1 \
\cb3 29\'a0\'a0\'a0\'a0\'a0\'a0\'a0 buf[0] = 3;\cb1 \
\cb3 30\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return buf;\cb1 \
\cb3 31\'a0\'a0\'a0\'a0\'a0 \}\cb1 \
\cb3 32\cb1 \
\cb3 33\'a0\'a0\'a0\'a0\'a0 int *\cb1 \
\
\cb3 Frame 1:\cb1 \
\cb3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 (gdb) f 1\cb1 \
\cb3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 #1\'a0 0x0000000000400774 in main () at simple.c:46\cb1 \
\cb3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 46\'a0\'a0\'a0\'a0\'a0\'a0\'a0 int *p[4] = \{ &mistake1 ()[1], &mistake2 ()[1], mistake3 (), mistake4 () \};\cb1 \
\
\cb3 Inhalt von P:\cb1 \
\cb3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 (gdb) p p\cb1 \
\cb3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 $4 = \{0x4, 0x602014, 0x7fffffffd360, 0x0\}\cb1 \
\
\
\pard\pardeftab720\sl280\partightenfactor0
\cf2 \cb4 simple-error:\cb1 \
\cb4 mistake1:\cb1 \
\cb4 Die lokale Variable buf wird nach der Funktion verworfen und der Speicherbereich ist in der main nicht mehr zugreifbar. Darum wurde ein Speicher f\'fcr buf reserviert (f\'fcr 2 int-Werte) und in dem zweiten Bereich die 1 hineingeschrieben.\cb1 \
\
\cb4 mistake2:\cb1 \
\cb4 Es wurde f\'fcr buf ein Speicherbereich f\'fcr vier char-Werte reserviert, es reicht aber ein Platz f\'fcr zwei int-Werte. In der main wird auf den zweiten Wert zugegriffen und nicht auf den dritten. Darum wurde der 2 in den zweiten int-Wert geschrieben.\cb1 \
\
\cb4 mistake3:\cb1 \
\cb4 Es muss f\'fcr buf der Platz f\'fcr einen int-Wert reserviert werden, mistake2_ ist genau ein int-Wert. Also reicht ein Speicherbereich mit der Gr\'f6\'dfe sizeof(mistake2_).\cb1 \
\
\cb4 mistake4:\cb1 \
\cb4 Es reicht wieder der Speicherbereich f\'fcr einen int-Wert und man braucht keinen f\'fcr 4-char Werte. Darum wird die 4 an erster Stelle in buf geschrieben. Ebenfalls darf buf nicht in der Funktion freigegeben werden.\cb1 \
\
\cb4 Free:\cb1 \
\cb4 Am Ende m\'fcssen alle in den Methoden angeforderten Speicherbereiche freigegeben werden. Bei Speicherbereichen mit mehr als einem Wert muss mittels p[index] - <int> zur\'fcck zum ersten Wert des Speicherbereichs gegangen werden, um den gesamten Bereich freizugeben. Der Wert, der an free(\'85) \'fcbergeben wird, ist die Startadresse des Bereichs.\cb1 \
\
\cb4 pde-error:\cb1 \
\cb4 \'a0\'a0\'a0\'a0\cb1 \
\cb4 1)\cb1 \
\cb4 Datei: askparams.c\cb1 \
\cb4 Zeile: 197\cb1 \
\
\cb4 Den Zugriffsindex von argsV[333] auf argsV[3] gesetzt, weil auf einen nicht vorhandenen Speicherbereich zugegriffen wurde. (Tippfehler)\cb1 \
\
\cb4 2)\cb1 \
\cb4 Datei: partdiff-seq.c\cb1 \
\cb4 Zeile: 96\cb1 \
\
\cb4 Es wurde zu wenig Speicher f\'fcr die Matrix reserviert. Der Speicherbereich wird jetzt statt mit 2 mit 3 multipliziert, damit gen\'fcgend Speicher vorhanden ist,\cb1 \
\
\cb4 3)\cb1 \
\cb4 Datei: partdiff-seq.c\cb1 \
\cb4 Zeile: 230\cb1 \
\
\cb4 Die Index-Parameter wurden vertauscht, somit wurde auf nicht vorhandene Speicherbereiche zugegriffen.\cb1 \
\
\cb4 Matrix[j - 1][m2][i] -> Matrix[m2][i][j-1]\cb1 \
\
\cb4 4)\cb1 \
\cb4 Datei: partdiff-seq.c\cb1 \
\cb4 Zeile: 164-170\cb1 \
\
\cb4 Der Speicherbereich der Matrix darf erst freigegeben werden, nachdem Matrix[1] und Matrix[2] freigegeben wurden, weil diese die Matrix selbst ben\'f6tigen.\cb1 \
\
\cb4 Der Pointer M muss selbst auch freigegeben werden.\cb1 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf2 \cb5 /*\cb1 \
\cb5 ** simple error demonstration to demonstrate power of valgrind\cb1 \
\cb5 ** Julian M. Kunkel - 17.04.2008\cb1 \
\cb5 */\cb1 \
\
\cb5 #include <stdio.h>\cb1 \
\cb5 #include <stdlib.h>\cb1 \
\
\cb5 /*\cb1 \
\cb5 es w\'e4re allgemein Interessant, wenn jede Funktion mit einer kleinen Beschreibung kommen k\'f6nnte,\cb1 \
\cb5 die sagen sollte, was eigentlich versucht wurde oder wie die Funktion aussehen sollte.\cb1 \
\cb5 */\'a0\cb1 \
\
\cb5 int * mistake1 ()\cb1 \
\cb5 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //Vor Korrektur buftyp = int Array\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //pointer buf auf Reserve von 6 Zellen der groesse int\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int* buf = malloc(6 * sizeof(int));\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //Initialisierung\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 buf[0] = 1;\'a0\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 buf[1] = 1;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 buf[2] = 2;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 buf[3] = 3;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 buf[4] = 4;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 buf[5] = 5;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //da buf auf buf[0] zeigt buf == 1\cb1 \
\cb5 \'a0 return buf;\cb1 \
\cb5 \}\cb1 \
\
\cb5 int * mistake2 ()\cb1 \
\cb5 \{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //Vor Korrektur buftyp == int pointer\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //Zuviel mit sizeof(char) da nur int also sizeof(int)\cb1 \
\cb5 \'a0 int* buf = malloc (sizeof (int) * 2);\'a0\cb1 \
\cb5 \'a0 //Anpassung der Adressen nach main-Aufruf\cb1 \
\cb5 \'a0 buf[1] = 2;\cb1 \
\cb5 \'a0 return buf;\cb1 \
\cb5 \}\cb1 \
\
\
\cb5 int *\cb1 \
\cb5 mistake3 ()\cb1 \
\cb5 \{\cb1 \
\cb5 \'a0 int mistake2_ = 0;\cb1 \
\cb5 \'a0 //wei\'df nicht, was hier versucht wurde\cb1 \
\cb5 \'a0 //buf braucht nur die groesse von mistake2\cb1 \
\cb5 \'a0 int *buf = malloc (sizeof(mistake2_));\cb1 \
\cb5 \'a0 buf[0] = 3;\cb1 \
\cb5 \'a0 return buf;\cb1 \
\cb5 \}\cb1 \
\
\cb5 int *\cb1 \
\cb5 mistake4 ()\cb1 \
\cb5 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //Anpassung der Groesse\cb1 \
\cb5 \'a0 int *buf = malloc (sizeof (int) * 1);\cb1 \
\cb5 \'a0 //Indexanpassung\cb1 \
\cb5 \'a0 buf[0] = 4;\cb1 \
\cb5 \'a0 //free (buf); //sonst ist Speicher nicht mehr erreichbar\cb1 \
\cb5 \'a0 return buf;\cb1 \
\cb5 \}\cb1 \
\
\
\cb5 void resetP(int* pointer)\cb1 \
\cb5 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if(pointer)\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 free(pointer);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 pointer = NULL;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\cb1 \
\cb5 \}\cb1 \
\
\cb5 void resetPint(int** pointer)\cb1 \
\cb5 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if(pointer)\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 free(*pointer);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 *pointer = NULL;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\cb1 \
\cb5 \}\cb1 \
\
\cb5 int\cb1 \
\cb5 main (void)\cb1 \
\cb5 \{\cb1 \
\cb5 \'a0 /* Modifizieren Sie die folgende Zeile nicht */\cb1 \
\cb5 \'a0 int *p[4] = \{ &mistake1 ()[1], &mistake2 ()[1], mistake3 (), mistake4 () \};\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cb1 \
\cb5 \'a0 printf ("1 %d\\n", *p[0]);\cb1 \
\cb5 \'a0 printf ("2 %d\\n", *p[1]);\cb1 \
\cb5 \'a0 printf ("3 %d\\n", *p[2]);\cb1 \
\cb5 \'a0 printf ("4 %d\\n", *p[3]);\cb1 \
\
\cb5 \'a0 /* mhh muss hier noch etwas gefreed werden? */\cb1 \
\cb5 \'a0 /* F\'fcgen sie hier die korrekten aufrufe von free() ein */\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //index f\'fcr die Freigabe anpassen und sicherstellen, dass p frei ist.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls1\ilvl0\cf2 \cb5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 //p[0] \'fcbergibt [1] --> Index muss -1 angepasst werden, damit den gesamten Array von mistake1 gefreet wird\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls2\ilvl0\cf2 \cb5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 //dasselbe f\'fcr p[1]\cb1 \
\pard\pardeftab720\sl280\partightenfactor0
\cf2 \cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 resetP(p[0]-1);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 resetP(p[1]-1);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //nur Adressen freigeben\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 resetPint(&p[2]);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 resetPint(&p[3]);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 return 0;\cb1 \
\cb5 \}\cb1 \
\
\cb5 //Auf2\cb1 \
\cb5 /*\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls3\ilvl0\cf2 \cb5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Der erste Fehler ist der Index der Matrix\'a0\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls4\ilvl0\cf2 \cb5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Matrix[j-1][m2][i] sollte [m2][i][j-1] sein\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls5\ilvl0\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \uc0\u8232 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls6\ilvl0\cf2 \cb5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Der n\'e4chste Fehler ist bei malloc der Matrix\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls7\ilvl0\cf2 \cb5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 malloc hat zu wenig Platz reserviert. Dies wurde erh\'f6ht.\'a0\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls8\ilvl0\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \uc0\u8232 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls9\ilvl0\cf2 \cb5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Weiter mit Valgrind konnte man finden:\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls10\ilvl0\cf2 \cb5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 AskParams --> askparams.c:197\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls11\ilvl0\cf2 \cb5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'a0sscanf (argV[333], "%d", interlines); --> sollte argV[3] sein? da [333] gar nicht vorhanden ist.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls12\ilvl0\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \uc0\u8232 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls13\ilvl0\cf2 \cb5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Dann noch freeMatrices mit 8 Bytes inside a block of 16 freed\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls14\ilvl0\cf2 \cb5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Da sollte man lieber mit einer For-Function alle Matrizen befreien?\'a0\cb1 \
\pard\pardeftab720\sl280\partightenfactor0
\cf2 \cb5 */\cb1 \
\
\
\cb5 /*****Hochleistungsrechnen Blatt01 *****/\cb1 \
\
\cb5 #include <stdio.h>\cb1 \
\
\cb5 // Definieren Sie ein enum cardd\cb1 \
\cb5 typedef enum \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 N = 1 << 0,\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 /* 0b0000000000000001 */\'a0\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 E = 1 << 1,\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 /* 0b0000000000000010 */\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 S = 1 << 2,\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \cb4 /* 0b000000000000001\cb5 0 */\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 W = 1 << 3\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 /* 0b0000000000001000 */\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}cardd;\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cb1 \
\
\cb5 // Definieren Sie ein 3x3-Array namens map, das Werte vom Typ cardd enth\'e4lt\cb1 \
\cb5 static cardd map[3][3] = \{\{-1,-1,-1\},\{-1,-1,-1\},\{-1,-1,-1\}\};\cb1 \
\
\cb5 // Die Funktion set_dir soll an Position x, y den Wert dir in das Array map eintragen\cb1 \
\cb5 // \'dcberpr\'fcfen Sie x und y um m\'f6gliche Array\'fcberl\'e4ufe zu verhindern\cb1 \
\cb5 // \'dcberpr\'fcfen Sie au\'dferdem dir auf G\'fcltigkeit\cb1 \
\cb5 void set_dir (int x, int y, cardd dir)\cb1 \
\cb5 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //To do : dir auf Gueltigkeit ueberpruefen\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if(x > 3 || x < 0 || y > 3 || y < 0)\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("Es gab eine ungueltige Eingabe\\n\\n");\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 else\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 map[x][y] = dir;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\cb1 \
\cb5 \}\cb1 \
\
\cb5 // Die Funktion show_map soll das Array in Form einer 3x3-Matrix ausgeben\cb1 \
\cb5 void show_map (void)\cb1 \
\cb5 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //To do : Darstellung anpassen. Ueberfluessige Symbole.\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("*********Start*********\\n\\n");\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //da die Grenzen festgelegt sind, kann man mit dem Wert drei arbeiten\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 for(int i = 0; i < 3; ++i)\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 for(int j = 0; j < 3; ++j)\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 switch(map[i][j])\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case 1: if(j==1)\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("__N__");\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else\{printf("N");\}\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case 2:printf("E");\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case 4: if(j==1)\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("__S__");\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else\{printf("S");\}\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case 8: printf("W");\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case 9:\'a0\'a0\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 /*\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Auswertung von N|W\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 0000000000001001 == Dezimal 9\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'e4hnliche Berechnung bei den anderen unten\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 */\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("NW");\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case 5: printf("NE");\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case 12:printf("SW");\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case 10:printf("SE");\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 default: if(j==1)\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("__0__");\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else\{printf("0");\}\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("\\n\\n");\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("*********Ende*********\\n\\n");\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("\\n");\cb1 \
\cb5 \}\cb1 \
\
\cb5 int main (void)\cb1 \
\cb5 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 // In dieser Funktion darf nichts ver\'e4ndert werden!\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 set_dir(0, 1, N);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 set_dir(1, 0, W);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 set_dir(1, 4, W);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 set_dir(1, 2, E);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 set_dir(2, 1, S);\cb1 \
\
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 show_map();\cb1 \
\
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 set_dir(0, 0, N|W);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 set_dir(0, 2, N|E);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 set_dir(0, 2, N|S);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 set_dir(2, 0, S|W);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 set_dir(2, 2, S|E);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 set_dir(2, 2, E|W);\cb1 \
\
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 show_map();\cb1 \
\
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 return 0;\cb1 \
\cb5 \}\cb1 \
\
\cb5 /******* pointer *******/\cb1 \
\
\cb5 #include <stdio.h>\cb1 \
\
\cb5 // Nach Korrektur der Funktion call_by_reference l\'f6schen\cb1 \
\cb5 //int TODO;\cb1 \
\
\cb5 void basic_pointer (int x)\cb1 \
\cb5 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int* adresse_von_x;\cb1 \
\
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 adresse_von_x = &x;\cb1 \
\
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("Der Wert von x ist: %d\\n", x);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("Die Adresse von x ist %p\\n", &x);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("Adresse von x mittels adresse_von_x %p\\n", adresse_von_x);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("Wert von x mittels adresse_von_x: %d\\n", *adresse_von_x);\cb1 \
\cb5 \}\cb1 \
\
\cb5 void basic_pointer2 (int x)\cb1 \
\cb5 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int* adresse_von_x = &x;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 // Eine andere Variable y erhaelt den Wert von x\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int y = x;\cb1 \
\
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("Der Wert von y ist %d\\n", y);\cb1 \
\
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 // Zuweisung \'fcber Adresse\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 x = 10;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 y = *adresse_von_x;\cb1 \
\
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("Der Wert von y ist %d\\n", y);\cb1 \
\cb5 \}\cb1 \
\
\cb5 void basic_pointer_changeValue (int x)\cb1 \
\cb5 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int* adresse_von_x = &x;\cb1 \
\
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 // \'c4ndern Sie den Wert von x zu 10\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 x = 10;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("x = %d\\n", x);\cb1 \
\
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 // \'c4ndern Sie den Wert von x \'fcber seine ADRESSE\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 *adresse_von_x = 20;\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("x = %d\\n", x);\cb1 \
\cb5 \}\cb1 \
\
\
\cb5 void call_by_reference (int* x)\cb1 \
\cb5 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 // \'c4ndern Sie den Wert, der an der Adresse steht, die im Wert x gespeichert ist\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 *x = 200;\cb1 \
\cb5 \}\cb1 \
\
\cb5 int main (void)\cb1 \
\cb5 \{\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int x = 5;\cb1 \
\
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 basic_pointer(x);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 basic_pointer2(x);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 basic_pointer_changeValue(x);\cb1 \
\
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("Wert von x vor der Funktion call_by_reference: %d\\n",x);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 call_by_reference(&x);\cb1 \
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("Wert von x nach der Funktion call_by_reference: %d\\n",x);\cb1 \
\
\cb5 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 return 0;\cb1 \
\cb5 \}\cb1 \
\
\
\pard\pardeftab720\sl280\partightenfactor0
\cf2 \cb4 Ole und Harry:\cb1 \
\
\cb4 Antworten:\cb1 \
\cb4 \'a0\'a0\'a0\'a0\cb1 \
\cb4 \'a0\'a0\'a0 1) Der Befehl 'cd' ist ein Befehl von Bash, darum wird er auf der Manual-Page von Bash aufgelistet und hat somit keine eigene Manual-Page.\cb1 \
\cb4 \'a0\'a0\'a0 2) Das Archiv ben\'f6tigt mehr Speicher als das Verzeichnis selbst.\cb1 \
\cb4 \'a0\'a0\'a0 3) Ja, mit\'a0 'tar cfvz [ARCHIV].tar.gz [VERZEICHNIS]\cb1 \
\
\cb4 MAP:\'a0\cb1 \
\cb4 #include <stdio.h>\cb1 \
\
\cb4 // Definieren Sie ein enum cardd\cb1 \
\cb4 typedef enum \{\cb1 \
\cb4 \'a0\'a0\'a0 N = 1 << 0, /* 0b0000000000000001 */\cb1 \
\cb4 \'a0\'a0\'a0 W = 1 << 1, /* 0b0000000000000010 */\cb1 \
\cb4 \'a0\'a0\'a0 E = 1 << 2, /* 0b0000000000000010 */\cb1 \
\cb4 \'a0\'a0\'a0 S = 1 << 3\'a0 /* 0b0000000000001000 */\cb1 \
\cb4 \} cardd;\cb1 \
\
\cb4 // Definieren Sie ein 3x3-Array namens map, das Werte vom Typ cardd enth\'e4lt\cb1 \
\cb4 cardd map[3][3];\cb1 \
\
\cb4 //\'dcberpr\'fcft die korrekte Eingabe und liefert das Ergebnis zur\'fcck\cb1 \
\cb4 int checkDir(cardd dir)\cb1 \
\cb4 \{\cb1 \
\cb4 \'a0\'a0\'a0 return (dir == N || dir == W ||dir == E ||dir == S ||\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 dir == (N|W) || dir == (N|E) ||dir == (S|W) ||dir == (S|E));\cb1 \
\cb4 \}\cb1 \
\
\cb4 // Die Funktion set_dir soll an Position x, y den Wert dir in das Array map eintragen\cb1 \
\cb4 // \'dcberpr\'fcfen Sie x und y um m\'f6gliche Array\'fcberl\'e4ufe zu verhindern\cb1 \
\cb4 // \'dcberpr\'fcfen Sie au\'dferdem dir auf G\'fcltigkeit\cb1 \
\cb4 void set_dir (int x, int y, cardd dir)\cb1 \
\cb4 \{\cb1 \
\cb4 \'a0\'a0\'a0 //\'dcberlauf verhindern\cb1 \
\cb4 \'a0\'a0\'a0 if((x < 3 && x >= 0) && (y < 3 && y >= 0) && checkDir(dir))\cb1 \
\cb4 \'a0\'a0\'a0 \{\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //Himmelsrichtung in Matrix setzen\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 map[x][y] = dir;\cb1 \
\cb4 \'a0\'a0\'a0 \}\cb1 \
\cb4 \}\cb1 \
\
\cb4 //Liefert die Himmelsrichtung als char-Array (String )zur\'fcck\cb1 \
\cb4 char* getDirectionString(cardd dir)\cb1 \
\cb4 \{\cb1 \
\cb4 \'a0\'a0\'a0 //Fallunterscheidung, um die korrekte Himmelsrichtung als Char-Array (String) auszugeben\cb1 \
\cb4 \'a0\'a0\'a0 switch((int)dir)\cb1 \
\cb4 \'a0\'a0\'a0 \{\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 case N:\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return "N";\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 case W:\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return "W";\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 case E:\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return "E";\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 case S:\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return "S";\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 case N|W:\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return "NW";\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 case N|E:\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return "NE";\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 case S|W:\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return "SW";\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 case S|E:\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return "SE";\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 default:\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return "0";\cb1 \
\cb4 \'a0\'a0\'a0 \}\cb1 \
\cb4 \}\cb1 \
\
\
\cb4 // Die Funktion show_map soll das Array in Form einer 3x3-Matrix ausgeben\cb1 \
\cb4 void show_map (void)\cb1 \
\cb4 \{\cb1 \
\cb4 \'a0\'a0\'a0 //Durchlauf der X-Koordinaten\cb1 \
\cb4 \'a0\'a0\'a0 for(int x = 0; x < 3; x++)\cb1 \
\cb4 \'a0\'a0\'a0 \{\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //Status, ob eine Reihe mit zwei Chars startet (0 = false)\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int startsWithTwoChars = 0;\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //Durchlauf der Y-Koordniaten\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 for(int y = 0; y < 3; y++)\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 char* direction;\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 cardd dir;\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 dir = map[x][y];\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 direction = getDirectionString(dir);\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 //Status, ob eine Reihe mit zwei Chars \'fcberpr\'fcfen (1 = true)\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if(dir == (N|W) || dir == (S|W))\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 startsWithTwoChars = 1;\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 //Himmelsrichtung ausgeben, je nach Gegebenheit formatieren\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if(y == 2)\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("%s", direction);\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else if (startsWithTwoChars)\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("%s__", direction);\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("%s___", direction);\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("\\n");\cb1 \
\cb4 \'a0\'a0\'a0 \}\cb1 \
\cb4 \'a0\'a0\'a0\'a0\cb1 \
\cb4 \'a0\'a0\'a0 printf("\\n");\cb1 \
\cb4 \'a0\'a0\'a0 printf("\\n");\cb1 \
\cb4 \'a0\'a0\'a0 printf("\\n");\cb1 \
\cb4 \}\cb1 \
\
\cb4 int main (void)\cb1 \
\cb4 \{\cb1 \
\cb4 \'a0\'a0\'a0 // In dieser Funktion darf nichts ver\'e4ndert werden!\cb1 \
\cb4 \'a0\'a0\'a0 set_dir(0, 1, N);\cb1 \
\cb4 \'a0\'a0\'a0 set_dir(1, 0, W);\cb1 \
\cb4 \'a0\'a0\'a0 set_dir(1, 4, W);\cb1 \
\cb4 \'a0\'a0\'a0 set_dir(1, 2, E);\cb1 \
\cb4 \'a0\'a0\'a0 set_dir(2, 1, S);\cb1 \
\cb4 \'a0\'a0\'a0\'a0\cb1 \
\cb4 \'a0\'a0\'a0\'a0\cb1 \
\cb4 \'a0\'a0\'a0 show_map();\cb1 \
\cb4 \'a0\'a0\'a0\'a0\cb1 \
\cb4 \'a0\'a0\'a0 set_dir(0, 0, N|W);\cb1 \
\cb4 \'a0\'a0\'a0 set_dir(0, 2, N|E);\cb1 \
\cb4 \'a0\'a0\'a0 set_dir(0, 2, N|S);\cb1 \
\cb4 \'a0\'a0\'a0 set_dir(2, 0, S|W);\cb1 \
\cb4 \'a0\'a0\'a0 set_dir(2, 2, S|E);\cb1 \
\cb4 \'a0\'a0\'a0 set_dir(2, 2, E|W);\cb1 \
\cb4 \'a0\'a0\'a0\'a0\cb1 \
\cb4 \'a0\'a0\'a0 show_map();\cb1 \
\cb4 \'a0\'a0\'a0\'a0\cb1 \
\cb4 \'a0\'a0\'a0 return 0;\cb1 \
\cb4 \}\cb1 \
\
\cb4 Pointer:\cb1 \
\cb4 \'a0\'a0\'a0\'a0\cb1 \
\cb4 \'a0\'a0\'a0 #include <stdio.h>\cb1 \
\
\cb4 void basic_pointer (int x)\cb1 \
\cb4 \{\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int* adresse_von_x;\cb1 \
\
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 adresse_von_x = &x;\cb1 \
\
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("Der Wert von x ist: %d\\n", x);\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("Die Adresse von x ist %p\\n", &x);\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("Adresse von x mittels adresse_von_x %p\\n", adresse_von_x);\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("Wert von x mittels adresse_von_x: %d\\n", *adresse_von_x);\cb1 \
\cb4 \}\cb1 \
\
\cb4 void basic_pointer2 (int x)\cb1 \
\cb4 \{\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int* adresse_von_x = &x;\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 // Eine andere Variable y erhaelt den Wert von x\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int y = x;\cb1 \
\
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("Der Wert von y ist %d\\n", y);\cb1 \
\
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 // Zuweisung \'fcber Adresse\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 x = 10;\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 y = *adresse_von_x;\cb1 \
\
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("Der Wert von y ist %d\\n", y);\cb1 \
\cb4 \}\cb1 \
\
\cb4 void basic_pointer_changeValue (int x)\cb1 \
\cb4 \{\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int* adresse_von_x = &x;\cb1 \
\
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 // \'c4ndern Sie den Wert von x zu 10\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 x = 10;\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("x = %d\\n", x);\cb1 \
\
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 // \'c4ndern Sie den Wert von x \'fcber seine ADRESSE\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 *adresse_von_x = 20;\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("x = %d\\n", x);\cb1 \
\cb4 \}\cb1 \
\
\
\cb4 void call_by_reference (int* x)\cb1 \
\cb4 \{\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 // \'c4ndern Sie den Wert, der an der Adresse steht, die im Wert x gespeichert ist\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 *x = 200;\cb1 \
\cb4 \}\cb1 \
\
\cb4 int main (void)\cb1 \
\cb4 \{\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int x = 5;\cb1 \
\
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 basic_pointer(x);\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 basic_pointer2(x);\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 basic_pointer_changeValue(x);\cb1 \
\
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("Wert von x vor der Funktion call_by_reference: %d\\n",x);\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 call_by_reference(&x);\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("Wert von x nach der Funktion call_by_reference: %d\\n",x);\cb1 \
\
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 return 0;\cb1 \
\cb4 \}\cb1 \
\
\cb4 Makefile:\cb1 \
\cb4 \'a0\'a0\'a0\'a0\cb1 \
\cb4 all: map pointer\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cb1 \
\cb4 map: map.o\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 gcc -o map map.o\cb1 \
\
\cb4 map.o: map.c\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 gcc -c map.c\cb1 \
\
\cb4 pointer: pointer.o\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 gcc -o pointer pointer.o\cb1 \
\
\cb4 pointer.o: pointer.c\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 gcc -c pointer.c\cb1 \
\
\cb4 clean:\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 rm -f map\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 rm -f pointer\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 rm -f *.o\cb1 \
\cb4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 rm -f *~\cb1 \
\
\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls15\ilvl0\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \
}